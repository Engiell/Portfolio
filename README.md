HEAD
# Anthony Bradley
# Professor Haruka Konishi
# CS-250-H2956 Software Development Lifecycle
# 12/17/2023

# How do I interpret user needs and implement them into a program? How does creating “user stories” help with this?
-Interpreting user needs and implementing them into a program involves understanding the software, what it's intended to be used for, and the users that will use it. Creating "user stories" help with this by creating a framework that focuses on the user. They help teams collaborate, and help create an over better product for the user with feedback. 

# How do I approach developing programs? What agile processes do I hope to incorporate into my future development work?
-Developing programs can involve several approaches. Teams can use either a waterfall approach or a more agile methodology. Agile processes that I plan to incorporate into my future development work involve communication and involvement. Improving on qualities that improve and promote collaboration with team memebrs, and openly communicate progress during scrum events and meetings.

# What does it mean to be a good team member in software development?
To me, being a good team member in software development involves being able to communicate and collaborate effectively. Utilizing experiences as developer and sharing that information with my team. Knowing when to ask for help, and when to reach out for further clarification. Having some personal responsibility, and owning my work. 

# CS-320

1. How can I ensure that my code, program, or software is functional and secure?
   -To ensure my software is functional and secure, it’s crucial to implement regular testing, code reviews, and static analysis. Adhere to secure coding practices and keep my software updated to prevent security vulnerabilities.

2. How do I interpret user needs and incorporate them into a program?
   -Interpreting user needs involves direct communication with users through interviews, creating user stories, and developing prototypes for feedback. This ensures my software aligns with user expectations and requirements.

3. How do I approach designing software?
   -When it comes to designing software, understanding the problem I'm solving is the first step. Planning and outlining my approach, adopting a modular design, and following an iterative development process will guide me in building effective and efficient software.
cs320-branch

# CS-350

- Summarize the projects and what problem it was solving?
  
  These two lab projects explored core embedded system techniques using a Raspberry Pi—one focused on implementing Pulse  Width Modulation (PWM) to control LED brightness, and the other on using button input and multithreading to manage LED behavior interactively. 
- What did you do particularly well?
  
  In the PWM lab, I had a good grasp of how frequency and duty cycle influence visual LED output, effectively using adjustable parameters to create dynamic lighting effects. The button input lab expanded on this by employing Python's threading module to separate LED behavior from user interaction, allowing real-time responsiveness without blocking other processes.
- Where could you improve?
  
  One improvement area is quality transitions through smoother fading in PWM or refining state transitions and debounce strategies in button handling. This would enhance the overall user experience.
- What tools and/or resources are you adding to your support network?
  
  I expanded my toolkit with the use of RPi.GPIO, circuit experimentation, and the application of Python multithreading. I also liked integrating serial communication libraries and leveraging displays in headless environments.
- What skills from this project will be particularly transferable to other projects and/or course work?
  
  The skills like modular code design, GPIO control, state machine logic, and user input handling will directly transfer to other programs/courses.
- How did you make this project maintainable, readable, and adaptable?
  
  Both projects emphasized the importance of adaptable code. This was done through descriptive functions, parameterization, and structure that supports debugging and scalability.
cs350-branch
